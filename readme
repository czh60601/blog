@[TOC](权限管理模块)
# 前言
如果你是为自己公司开发系统的话，刚开始很有可能并没有涉及到复杂权限控制,或者当时的开发周期短或者老板拍板决定的不使用或直接用一个int值来控制角色，但随着项目的扩展，会发现权限管理起来越来越麻烦，这个时候你可以考虑直接使用现成的权限管理框架或者自己整一个。而我，选择了后者。

# 资源管理
## 设计思路及可能遇到的问题
时间还是有点久了，就简单提下当时的思路。
### 资源访问路径
我们可以把所有的请求都当成一个资源,包括页面的加载或者业务层的某一个判断等等。那么资源的访问路径就可以是如下顺序：

```mermaid
flowchat
st=>start: 开始
e=>end: 结束
notfound=>end: 资源不存在
op=>operation: 发起资源请求
cond=>condition: 资源是否存在?
getRes=>operation: 获取资源

roleCheck=>operation: 权限检查

st->op->cond
cond(yes)->getRes->roleCheck->e
cond(no)->notfound->e
```
### 资源分类
每一个权限就相当于一个资源，资源自然是要进行分来，这样不管是查询还是使用都会方便很多。分类方法的话可以根据资源的使用情景进行分类，我这里就分成5个类:
```java
    	/**
    	 * 接口类请求地址
    	 */
    	public static final int TYPE_URL = 1;
    	/**
    	 * 资源展示类视图
    	 */
    	public static final int TYPE_VIEW = 2;
    	/**
    	 * 无页面菜单
    	 */
    	public static final int TYPE_MENU = 3;
    	/**
    	 * 页面菜单
    	 */
    	public static final int TYPE_PAGE = 4;
    	/**
    	 * 操作类:包含后台接口和前端展示
    	 */
    	public static final int TYPE_ACTION = 5;
```
如果不是有很严谨的要求的话可以把``5,2``合在一起，我这里的建议是分开，虽然在代码上没有多大意义，但是有助于主观区分，毕竟资源始终是要有人去维护的。至于``1，3，4``主要是用于菜单加载,接口是不需要展示出来的,毕竟有些接口是不能暴露出去或者涉及的业务比较重要。至于菜单的和子菜单(也就是页面)的区分也是用于主观上的,毕竟代码方面还是好处理的。

### 资源结构设计
既然资源分类已经出来了，那么就可以根据分类来设计对象结构。
```java
	private Integer id;
	private String resname;
	private String key;
	private String value;
	private String path;
	/**
	 * 图标
	 */
	private String ico;
	/**
	 * 从属上级资源,菜单或者页面
	 */
	private int flow;
	/**
	 * 从属上级的名称
	 */
	private String flowname;
	private String flowtree;
	private int type;
	
	private boolean ipcheck;
	private boolean rolecheck;
	private boolean logincheck;
```
``id,resname,path,ico``没什么好说的,要说的话就是图标可以选择存前端样式名称比如:``fa-sign-out``
这里重点说下其他几个字段。首先我们要考虑的问题是如何把这些资源给串起来，这样便于我们识别，毕竟同名资源是无法避免的。我这里使用的办法就是把这个资源的家族树保存下来``flowtree``，这里的家族树也只是保存了所有父级加上他自己的id,这样在生成菜单或者资源树或者对资源进行操作的时候就会方便很多。比如要查询所有子菜单,就可以直接根据flowtree来模糊匹配就行。``但是需要注意的是,这个id不能从一个小数开始，这样会把其他的也给查出来，比如:查询5的子节点,但是会把15,25等等也给查出来,他们可能并不是5的子节点``
字段``flow``的用处主要是用于把直接父级资源的家族树给拉去出来,这样就可以直接设置当前资源的家族树了,至于怎么获取自己的ID，如果是存入数据库的话,可以直接查询出来,比如MySql里就是:
```mysql 
SELECT LAST_INSERT_ID();
```
至于``ipcheck,relecheck,logincheck``则是用于条件检查的，分别对应 ``白名单，角色，登录``
#### 资源快速检索
然后重点来了,当把所有资源都加载进内存后,资源的检索就决定了权限管理模块的好坏,如果一个资源检索很慢,那和直接用角色ID做判断有何区别，而且也会也行业务效率，甚至影响服务器性能。
为了达到更快的检索我把资源添加了不同的索引,这里的索引指的是在内存中建立索引来达到快速查询的目的,我使用的是 ``HashMap`` 映射表,毕竟哈希表的查询速度公认的。
那么如何建立索引就比较重要了，在这个模块里我一共建立了4个索引,虽然有个索引一直没用到就是了
```java
	//PATH索引
	private static Map<String,Resources> pathMap = new HashMap<String, Resources>();
	//KeyValue索引
	private static Map<String,Map<String,Resources>> kvMap = new HashMap<String, Map<String,Resources>>();
	//ResourcesID索引
	private static Map<Integer,Resources> resourcesMap = new HashMap<Integer,Resources>();
	//RoleIDResourcesTree索引
	private static Map<Integer,ResourcesTree> roleResourcesTree = new HashMap<Integer, ResourcesTree>();
```
##### 第一个:地址索引 - pathMap
这个索引主要是用于权限过滤器使用,根据保存的``资源地址(path)``来直接获取资源，毕竟请求地址是很好获取的，甚至可以用模糊匹配的方式来批量授权，这个时候对第三方模块就很实用了，毕竟不可能去把它所有的请求都翻出来添加进去。比如我们可以给``druid``连接池自带的监控进行授权
##### 第二个:KeyValue索引 - kvMap 
首先说下之前没有提到的 ``key，value``这两个字段，``key``这个字段由资源所属的``菜单.子菜单``组成，如果是多级菜单可以直接拼接上去,方便前端菜单树的页面定位，``value``则是用来区分不同的资源用。比如:``权限管理->资源管理`` 页面 ``key``设置成 ``rbac.resources``，``value``设置成``resources``，资源``编辑权限操作``的 ``key``和``资源管理``页面一样,然后``value``设置成``edit``
根据``key，value``就可以生成一个多级的``HasmMap``映射从而达到快速检索的目的。
##### 第三个:资源ID索引 - resourcesMap
这个就只是单纯的把资源ID提出来做的映射，实际使用中发现并没有用到
##### 第四个:角色菜单树索引 - roleResourcesTree
这里要首先说下菜单树的定义:
```java
	private Integer id;
	private Resources resources;
	private Map<Integer,ResourcesTree> children;
```
这里的``ID``指的是``资源ID``，``resources``则是当前的资源，``children``则是该资源下的子资源。
然后第一层 ``Map``的``key``就是角色的ID,通过这个映射就可以直接在前端生成角色对应的菜单。

##### 权限检查
在拿到资源后就可以进行权限检查了，根据``ipcheck,rolecheck,logincheck``这几个字段做相应的检查。
1. ``ipcheck``白名单的话直接根据设置的白名单列表进行匹配即可。
2. ``logincheck``则直接进行判断当前请求用户是否已经登录即可。
3. ``rolecheck``则是根据获取到的资源ID对用户进行检查。

#### 部分代码参考
##### 资源索引生成
```java
	logger.info("生成资源索引");
	for(;!resList.isEmpty();){
		Resources resItem = resList.remove(0);
	
		if(StringUtils.isNotBlank(resItem.getPath())){
			pathMapTemp.put(resItem.getPath(), resItem);
		}
		if(kvMapTemp.containsKey(resItem.getKey())){
			kvMapTemp.get(resItem.getKey()).put(resItem.getValue(), resItem);
		}else{
			Map<String,Resources> vMap = new HashMap<String, Resources>();
			kvMapTemp.put(resItem.getKey(), vMap);
			vMap.put(resItem.getValue(), resItem);
		}
		resourcesMapTemp.put(resItem.getId(), resItem);
	}
	logger.info("生成资源索引完成");
	
	logger.info("生成角色主菜单索引");
	Map<Integer,ResourcesTree> roleResourcesTreeTemp = new HashMap<Integer, ResourcesTree>();
	for(Integer roleId:roleMapTemp.keySet()){
		Role roleItem = roleMapTemp.get(roleId);
	
		ResourcesTree rootTree = new ResourcesTree();//根目录
		Set<Integer> created = new HashSet<Integer>();//已经生成过多的资源ID
		List<String> resListItem = new ArrayList<String>(roleItem.Reslist);//不能直接做移除,要复制一个副本来操作
	
		for(;!resListItem.isEmpty();){
			String resId = resListItem.remove(0);
			Resources resItem = resourcesMapTemp.get(Integer.parseInt(resId));
			if(resItem.getType()==Resources.TYPE_MENU || resItem.getType()==Resources.TYPE_PAGE){
				//是否存在父级
				if(resItem.getFlow()!=0){
					//检测父级是否创建
					if(created.contains(resItem.getFlow())){
						String flowtree = resItem.getFlowtree().replaceAll("\\,?\\d+$", "");//剔除自己
	
						ResourcesTree root = rootTree;
						//根据家族树查找父级
						for(String key:flowtree.split(",")){
							root = root.getChildren().get(Integer.parseInt(key));
						}
	
						//创建子节点
						ResourcesTree treeItem = new ResourcesTree();
						treeItem.setId(resItem.getId());
						treeItem.setResources(resItem);
	
						if(root.getChildren()==null){
							Map<Integer,ResourcesTree> children = new LinkedHashMap<Integer, ResourcesTree>();
							children.put(resItem.getId(), treeItem);
							root.setChildren(children);
						}else{
							Map<Integer,ResourcesTree> children = root.getChildren();
							children.put(resItem.getId(), treeItem);
						}
						created.add(resItem.getId());
					}else{
						//判断父节点是否被授权,否这跳过创建,并记录已存日志
						if(!resListItem.contains(resItem.getFlow())){
							logger.error("权限异常["+resId+"]:"+roleItem.getId()+"/"+roleItem.getRolename());
							System.out.println("权限异常["+resId+"]:"+roleItem.getId()+"/"+roleItem.getRolename());
							break;
						}else{
							resListItem.add(resId);
							//父级未创建放回
							continue;
						}
					}
				}else{
					ResourcesTree treeItem = new ResourcesTree();
					treeItem.setId(resItem.getId());
					treeItem.setResources(resItem);
	
					if(rootTree.getChildren()==null){
						Map<Integer,ResourcesTree> children = new LinkedHashMap<Integer, ResourcesTree>();
						children.put(resItem.getId(), treeItem);
						rootTree.setChildren(children);
					}else{
						Map<Integer,ResourcesTree> children = rootTree.getChildren();
						children.put(resItem.getId(), treeItem);
					}
					created.add(resItem.getId());
				}
			}
		}
	
		roleResourcesTreeTemp.put(roleId, rootTree);
	}
	logger.info("生成角色主菜单索引完成");
```
##### 索引查询接口
```java
	/**
	 * 获取菜单树
	 * @return 
	 */
	public static ResourcesTree getTreeByRoleId(Integer roleId){
		Role role = getRoleByID(roleId);
		if(role == null || !roleResourcesTree.containsKey(roleId)){
			return new ResourcesTree();
		}
		return roleResourcesTree.get(roleId);
	}

	/**
	 * 根据KeyValue获取资源
	 * @return
	 */
	public static Resources getResourcesByKeyValue(String key,String value){
		if(kvMap.containsKey(key)){
			return kvMap.get(key).get(value);
		}
		return null;
	}

	/**
	 * 根据path获取资源
	 */
	public static Resources getResourcesByPath(String path){
		return pathMap.get(path);
	}

	/**
	 * 获取角色
	 */
	public static Role getRoleByID(Integer roleId){
		return roleMap.get(roleId);
	}

	public static boolean hasResourcesSet(String key,String value,Integer roleId){
		Resources res = getResourcesByKeyValue(key, value);
		if(res!=null){
			Role role = getRoleByID(roleId);
			if(role!=null){
				return role.Reslist.contains(res.getId().toString());
			}
		}
		return false;
	}

	public static boolean hasResourcesSet(String path,Integer roleId){
		Resources res = getResourcesByPath(path);
		if(res!=null){
			Role role = getRoleByID(roleId);
			if(role!=null){
				return role.Reslist.contains(res.getId().toString());
			}
		}
		return false;
	}
```

## 角色管理
角色管理就比较灵活了,我这里也是做了一个``角色ID索引``用作用户快速获取自己的角色。
这里就直接贴出角色和用户的设计:
```java
public class Role {
	private int id;
	private String rolename;
	/**
	 * 父级
	 */
	private int parent;
	private String pname;
	/**
	 * 家族树
	 */
	private String family;
	private String info;
	private boolean admin;

	public List<String> Reslist = new ArrayList<String>();
	public List<String> FamilyList = new ArrayList<String>();

	public void setFamily(String family){
		List<String> familyTemp = new ArrayList<String>();
		if(StringUtils.isNotBlank(family)){
			for(String item:family.split(",")){
				familyTemp.add(item.trim());
			}
		}
		FamilyList = familyTemp;
		this.family = family;
	}

	public void setResList(String resList){
		List<String> listTemp = new ArrayList<String>();
		if(StringUtils.isNotBlank(resList)){
			for(String item:resList.split(",")){
				listTemp.add(item.trim());
			}
		}
		Reslist = listTemp;
	}
}

public class UserObject {
	protected Integer uid;
	protected Integer role;
	protected String roleName;

	public boolean hasItem(String key,String value){
		return ManagerUtil.hasResourcesSet(key, value, role);
	}
}
```
*角色的家族树就可以灵活一点,这样方便查询子角色，比如员工管理里面，人事和财务的都要查看其他人的部分信息等等，然后 ``hasItem``则是用来检查角色是否拥有该资源的接口，主要用于``前端``和``业务层``的需求,至于源码的话后面整理出来会提交到GitHub*
